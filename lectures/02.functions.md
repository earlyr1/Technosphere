# Компиляция и компоновка

1. Обработка препроцессором
2. Компиляция
3. Компоновка

```
// a.h
#pragma once

int foo();
```

```
// a.cpp
#include "a.h"

int foo() { return 3; }
```

```
// b.cpp
#include "a.h"

int main()
{
    return foo();
}
```

##### Еденицы трансляции:

```
// a.cpp
int foo();

int foo() { return 3; }
```

```
// b.cpp
int foo();

int main()
{
    return foo();
}
```

##### Основные ошибки компоновки
1. Не найден символ (undefined symbols)
2. Найдено несколько символов с одним именем (multiple definition)

##### Защита от повторного включения
```c++
//buffer.h

namespace utils
{
    class Buffer
    {
         ...
    }
}
```
```c++
// text_processor.h
#include "buffer.h"

...
```
```c++
// main.cpp
#include "buffer.h"
#include "text_processor.h"
```
В одной единице трансляции два объявления класса `utils::Buffer`, компилятор не знает какое использовать.
```c++
// buffer.h
#ifndef UTILS_BUFFER_H
#define UTILS_BUFFER_H

...

#endif
```
```c++
// buffer.h
#pragma once
```

##### Циклическое включение

```c++
// a.h
#include "b.h"

class A
{
    B* b;
};
```

```c++
// b.h
#include "a.h"

class B
{
};
```

##### Предварительное объявление (forward declarations)

```c++
// a.h

class B;

class A
{
    B* b;
};
```

```c++
// a.cpp
#include "b.h"

#include "a.h"
```

```c++
// b.h
#include "a.h"

class B
{
};
```

### Пространства имен

Логическая группировка уникальных идентификаторов.

Проблема:

```
// my lib
int hash(const char* data, size_t size);
```
```
// external lib
int hash(const char* data, size_t size);
```

Решение:

```
// my lib
namespace mylib
{
    int hash(char* data, size_t size);
}

mylib::hash(data, size); // вызов из mylib
hash(data, size); // вызов из external lib
```

И снова проблема:

```
using namespace mylib;

hash(data, size); // ???
hash(data, size); // ???
```

> Не используйте using namespace в заголовочных файлах!

Относительно нормально:

```
void foo()
{
    using namespace mylib;
    // видимо все из mylib
}
```

```
void foo()
{
    using namespace mylib::hash;
    // видима только hash
}
```

Нормально:

```
void foo()
{
    namespace ml = mylib;
    ml::hash(data, size);
}
```

Пространства имен могут быть любой вложенности:

```
namespace mylib
{
    namespace utils
    {
        int hash(const char* data, size_t size);
    }
    namespace net
    {
        bool ping(const char* name);
    }
}
```

### Функции
```c++
int rollDice()
{
    return 4;
}
```
```c++
void print(int x)
{
    std::cout << x << std::endl;
}
```

##### Перегрузка функций
```c++
void print(bool x)
{
    std::cout << (x ? "true" : "false") << std::endl;
}
```

##### Опасность перегрузки
```c++
void print(const std::string& x)
{
    std::cout << "string" << std::endl;
}

void print(bool x)
{
    std::cout << "bool" << std::endl;
}

print("hello!");

```

### Конвенции вызова для 32 бит
##### cdecl
Исторически принятое соглашение для языка С.

Аргументы функций передаются через стек, справа налево. Аргументы, размер которых меньше 4-х байт, расширяются до 4-х байт. Очистку стека производит вызывающая программа.

Результат возвращается через регистры.

Перед вызовом функции вставляется код, называемый прологом (prolog) и выполняющий следующие действия:
- сохранение значений регистров, используемых внутри функции
- запись в стек аргументов функции

После вызова функции вставляется код, называемый эпилогом (epilog) и выполняющий следующие действия:
- восстановление значений регистров, сохранённых кодом пролога
- очистка стека (от локальных переменных функции)

##### thiscall
Соглашение о вызовах, используемое компиляторами для языка C++ при вызове методов классов.

Отличается от **cdecl** соглашения только тем, что указатель на объект, для которого вызывается метод (указатель this), записывается в регистр.

##### fastcall
Самый быстрый способ.

Передача параметров через регистры, если для сохранения всех параметров и промежуточных результатов регистров не достаточно, используется стек (в gcc через регистры передаются первые 2 параметра).

Соглашение не стандартизировано.

### Смотрим сгенерированный код
```c++
[[gnu::fastcall]]
void foo1(int x, int y, int z, int a)
{
}

void foo2(int x, int y, int z, int a)
{
}

void bar1()
{
    foo1(1, 2, 3, 4);
}

void bar2()
{
    foo2(5, 6, 7, 8);
}

int main()
{
}
```
```
g++ test.cpp -o test.o -O0 -m32
```
```
objdump -d test.o > test.txt
```
```
000005c8 <_Z4bar1v>:
 5c8:	6a 04                	push   $0x4
 5ca:	6a 03                	push   $0x3
 5cc:	ba 02 00 00 00       	mov    $0x2,%edx
 5d1:	b9 01 00 00 00       	mov    $0x1,%ecx
 5d6:	e8 b5 ff ff ff       	call   590 <_Z4foo1iiii>
 5dd:	c3                   	ret    

000005eb <_Z4bar2v>:
 5eb:	6a 08                	push   $0x8
 5ed:	6a 07                	push   $0x7
 5ef:	6a 06                	push   $0x6
 5f1:	6a 05                	push   $0x5
 5f3:	e8 b3 ff ff ff       	call   5ab <_Z4foo2iiii>
 5fd:	c3                   	ret   
```

### Конвенции вызова для 64 бит

- Специфичны для платформы
- На x86-64 через регистры передаются 4 параматра, для С++ первый параметр при вызове метода - this

### Встраивание функций (inline)
```c++
inline void foo()
{
	...
}
```
> Компилятор умный и скорее всего проигнорирует inline, но можно попросить настойчивей

```c++
// ms vc
__forceinline void foo()
{
    ...
}
```
```c++
// gcc
__attribute__((always_inline)) void foo()
{
    ...
}
```
> Все равно нет гарантий

##### Тот случай когда макросы уместны
```c++
#ifdef __GNUC__
#define __forceinline __attribute__((always_inline))
#endif
```

### Передача аргументов в функции
#####  По значению
```c++
void foo(int x) { ... }
void bar(BigObject o) { ... }
```
- В функции окажется копия объекта, ее изменение не отразится на оригинальном объекте
- Копировать большие объекты может оказаться накладно

##### По ссылке
```c++
void foo(int& x) { ... }
void bar(BigObject& o) { ... }
```
- Копирования не происходит, все изменения объекта внутри функции отражаются на объекте
- Следует использовать, если надо изменить объект внутри функции

```c++
void swap(int& x, int& y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
```

##### По константной ссылке
```c++
void foo(const int& x) { ... }
void bar(const BigObject& o) { ... }
```
- Копирования не происходит, при попытке изменения объекта будет ошибка
- Большие объекты выгодней передавать по ссылке, маленькие - бессмысленно

##### По указателю
```c++
void foo(int* x) { ... }
void bar(BigObject* o) { ... }

void foo(const int* x) { ... }
void bar(const BigObject* o) { ... }
```
- Копирования не происходит
- Если указатель константный объект, то при попытке изменения объекта будет ошибка
- Есть дополнительный уровень косности, возможно придется что-то подгрузить из дальнего участка памяти
- Реализуется optional-концепция

```c++
int countObject(time_t* fromDate, time_t* toDate)
{
    const auto begin = 
        fromDate == nullptr
            ? objects_.begin()
            : objects_.findFirst(fromDate);

    ...
}
```

##### По универсальной ссылке
```c++
void foo(int&& x) { ... }
void bar(BigObject&& o) { ... }
```
Поговорим в отдельной лекции.

#### Указатель на функцию
```c++
void foo(int x)
{
    ...
}

typedef void (*FooPtr)(int);

FooPtr ptr = foo;

ptr(5);
```

```c++
using FooPtr = void(*)(int);
```

#### Функции высшего порядка
Функция высшего порядка — функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата. Основная идея состоит в том, что функции имеют тот же статус, что и другие объекты данных.

```c++
using MoveFunctionPtr = void (*)(int& x, int& y);

void moveLeft(int& x, int& y) { ... }
void moveRight(int& x, int& y) { ... }

std::vector<MoveFunctionPtr> trajectory = 
    {
        moveLeft, 
        moveLeft, 
        moveRight, 
    };
```

#### std::function
```c++
using MoveFunction = std::function<void (int& x, int& y)>;

std::vector<MoveFunctionPtr> trajectory = 
    {
        moveLeft, 
        moveLeft, 
        moveRight, 
        [](int& x, int& y) 
        {
            ...
        },
        moveLeft
    };
```

#### Синтаксис лямбда-функции

```c++
[список_захвата](список_параметров) { тело_функции }
```
```c++
[список_захвата](список_параметров) mutable { тело_функции }
```
```c++
[список_захвата](список_параметров) -> тип_возвращаемого_значения
{ тело_функции }
```
```c++
[список_захвата](список_параметров) mutable -> тип_возвращаемого_значения
{ тело_функции }
```

Дополнительно для лямбды можно указать ```noexcept```

#### Захват переменных

```c++
int x = 5;
int y = 7;
auto foo = [x, &y]() { y = 2 * x };
foo();
```
```c++
// Захват всех переменных в области видимости по значению
auto foo = [=]() {};
```
```c++
// Захват всех переменных в области видимости по ссылке
auto foo = [&]() {};
```

Использование переменных, определённых в той же области видимости, что и лямбда-функция называют замыканием. 

### Как выделить память в C++

```
char* data = (char*) malloc(1024);
...
free(data);
```

```
std::unique_ptr<char[]> data(new char[1024]);
// или так
auto data = std::make_unique<char[]>(1024);
```

```
char* ptr = data.get() // Указатель
char x = data[100]; // Элемент 100
data.reset(); // Явное освобождение памяти
```

### Практическая часть

Нужно написать программу считающую сколько раз простое число встречается в указанном диапазоне массива.

Массив состоит из упорядоченных по возрастанию целых чисел (int), числа находятся в диапазоне [0, 100000]. На вход программы поступают пары чисел из первого и последнего числа в диапазоне. Нужно найти в массиве эти числа и вывести в консоль сколько простых чисел находится между ними включительно.

Пример:

```
3 4 4 5 7 8 8 9 11 11 15

./test 4 15
4
```

Если заданного числа в массиве нет, то вывести в консоль 0.

Пример:

```
3 4 4 5 7 8 8 9 11 11 15

./test 6 15
0
```

Если ввод некорректен или произошла внутренняя ошибка, вернуть return -1, иначе программа должна возвращать return 0.

> Стандартные алгоритмы использовать нельзя.

```c++
int main(int argc, char* argv[])
{
    for (int i = 1; i < argc; ++i)
    {
        int v = std::atoi(argv[i]);
        std::cout << v;
    }
    return 0;
}
```

Массив с данными находится в директории с домашними заданиями - это файл numbers.zip, просто распакуйте его в свою директорию с кодом и в своем коде подключите его:

```c++
#include "numbers.dat"

// Data - массив
// Size - размер массива
```

> Заливать этот файл в репозиторий не надо!!!

Примерный вывод прогона тестов:

```
./test 12 18
ok
./test 1 99999
ok
./test 25 25
ok
./test 30 29
ok
./test 99999 1
ok
./test 97 62285
ok
./test 41753 91449
ok
./test 3 99993
ok
./test 3
ok
./test
ok
./test 3 3 3
ok
./test 12 18 1 99999
ok
bencmarking
0.120469093323 sec
```

> Если программа работает дольше 10 секунд - она будет убита по таймауту

EOF
